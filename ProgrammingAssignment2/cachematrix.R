## The following functions take care of computing and then caching the inverse 
## of a matrix given as input argument
##-----------------------------------------------------------------------------
## 'makeCacheMatrix()' get in input a matrix and return a list of four fuctions
## that are used for cache or retrieve both the matrix to be inverted and its
## inverse:
## 'setmat()': set the matrix to be inverted
## 'getmat()': return the matrix setted to be inverted
## 'setinv()': set (cache) the inverse matrix
## 'getinv()': return the inverse matrix computed or cached
##-----------------------------------------------------------------------------
## 'cacheSave()' get as input argument the list generated by 'makeCacheMatrix' 
## and check for a cached inverse already computed, if not present it computes 
## the inverse matrix retrieved from the list generated by 'makeCacheMatrix'
## and sets (caches) the result in the previous list. 
## Before computing the inverse, the function checks if:
## the matrix is square (nrow = ncol), or if it is only a placeholder
## the matrix is invertible (determinat != 0)
##-----------------------------------------------------------------------------

## 'makeCacheMatrix(x)' gets as input argument a matrix that can be also null
## (makeCacheMatrix()) and returns a list of the four functions neede for 
## cache or retrieve both the matrix to be inverted and its inverse. Every time 
## the input matrix change the inverse cached is resetted to NULL


makeCacheMatrix <- function(x = matrix()) {

        
        mat_inv <- NULL  # matrix initialization
        
        # set the new matrix and reinitialise the inverse placeolder
        setmat <- function(y) {
                x <<- y
                mat_inv <<- NULL
        }
        
        # return the setted matrix
        getmat <- function() x
        
        # set (cache) the inverse computed by 'cacheSave()'
        setinv <- function(inverse) mat_inv <<- inverse
        
        # return the inverse matrix
        getinv <- function() mat_inv
        
        # return the list of four functions
        list(setmat = setmat, getmat = getmat,
             setinv = setinv,
             getinv = getinv)
        
}


## 'cacheSave(x)' get as input argument the list generated by 'makeCacheMatrix'
## and returns and caches (sets in the list) the inverse of the matrix setted
## before. If the matrix is not yet setted in the list (it is only a 
## placeolder), or if it is not square, or it is not invertible, the function 
## returns an alert message.

cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
        
        # get the matrix to be inverted 
        mat <- x$getmat()

        # Retrieve the mat_inv if present
        mat_inv <- x$getinv()

        # check if the inverse has been already done before
        if(!is.null(mat_inv)) {
                message("getting cached inverse matrix")
                return(mat_inv)
        }
        
        ## check if the matrix is square or if it is only a placeholder
        if ((nrow(mat) != ncol(mat)) | (nrow(mat) ==1)) {
                message("The matrix is not square")
                message(paste("nrow = ",as.character(nrow(mat))," ", 
                              "ncol = ", as.character(ncol(mat))))
                return(invisible())
        }
        
        ## chek if the matrix is invertible
        if (det(mat) == 0) {
                message("The matrix cannot be inverted")
                return(invisible())
        }
        
       
        # mat_inv = NULL then
        # compute identity matrix needed for 
        # computing the 'x' inverse
        ident_mat <- diag(nrow = nrow(mat))
        
        # compute the inverse and cache it
        mat_inv <- solve(mat,ident_mat)
        x$setinv(mat_inv)
        mat_inv
}
